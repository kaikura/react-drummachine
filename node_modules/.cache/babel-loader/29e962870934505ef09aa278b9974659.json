{"ast":null,"code":"class MainSketchClass {\n  // custom polygon array\n  constructor() {\n    this.comboBox = 0;\n    this.canvasWidth = 800;\n    this.canvasHeight = 600;\n    this.instrumentMode = 0;\n    this.layerNumber = 1;\n    this.kindOfShape = 0;\n    this.selectedShape = 0;\n    this.selectedShape2 = 0;\n    this.maxNumShapes = 1;\n    this.maxNumShape2 = 2;\n    this.numCustShapes = 0;\n    this.circleLandW = 500;\n    this.clockCircleScaleSize = 1;\n    this.currentGrain = 0;\n    this.currentGrain2 = 0;\n    this.nGrain = 16;\n    this.firstLayerLandW = 500;\n    this.rot1 = new Array(1);\n    this.shp1 = new Array(1);\n    this.rot2 = new Array(2);\n    this.shp2 = new Array(2);\n    this.polygon_array = new Array(this.nGrain - 1);\n    this.polygon_array_c = new Array();\n    this.polygon_array2 = new Array(this.nGrain - 1);\n    this.initializeArrays();\n    this.initializePolygonArrays();\n  }\n\n  initializePolygonArrays() {\n    //LOOP TO GENERATE DIFFERENT SHAPES\n    for (let i = 2; i <= this.nGrain; i++) {\n      //starts from 2 since we need a line as the simplest shape possible\n      this.polygon_array[i - 2] = new Array(i);\n\n      for (let h = 0; h < this.polygon_array[i - 2].length; h++) {\n        this.polygon_array[i - 2][h] = Math.round(this.nGrain * h / this.polygon_array[i - 2].length);\n      }\n    }\n\n    for (let i = 2; i <= this.nGrain; i++) {\n      //starts from 2 p5.since we need a line as the simplest shape possible\n      this.polygon_array2[i - 2] = new Array(i);\n\n      for (let h = 0; h < this.polygon_array2[i - 2].length; h++) {\n        this.polygon_array2[i - 2][h] = Math.round(this.nGrain * h / this.polygon_array2[i - 2].length);\n      }\n    }\n  }\n\n  initializeArrays() {\n    for (let i = 0; i < this.rot1.length; i++) {\n      this.rot1[i] = 0;\n    }\n\n    for (let i = 0; i < this.rot2.length; i++) {\n      this.rot2[i] = 0;\n    }\n\n    for (let i = 0; i < this.shp1.length; i++) {\n      this.shp1[i] = i;\n    }\n\n    for (let i = 0; i < this.shp2.length; i++) {\n      this.shp2[i] = i;\n    }\n  }\n\n  setup(p5, canvasParentRef) {\n    p5.createCanvas(p5.width = this.canvasWidth, p5.height = this.canvasHeight).parent(canvasParentRef); // use parent to render canvas in this ref (without that p5 render this canvas outside your component)\n\n    p5.background(100, 150, 100);\n    const buttondx = p5.createButton('+1');\n    buttondx.position(p5.width * 0.87, p5.height * 0.8);\n    const buttonsx = p5.createButton(\"-1\");\n    buttonsx.position(p5.width * 0.87 - 35, p5.height * 0.8);\n    const buttonenc = p5.createButton(\"Encoder Button\");\n    buttonenc.position(p5.width * 0.8, p5.height * 0.84);\n    buttondx.mousePressed(this.encoderInc.bind(this));\n    buttonsx.mousePressed(this.encoderDec.bind(this));\n    buttonenc.mousePressed(this.encoderButt.bind(this));\n    const buttoncust = p5.createButton(\"X\");\n    buttoncust.position(p5.width * 0.85, p5.height * 0.2);\n    buttoncust.mousePressed(this.deleteShape.bind(this)); //button new Circle\n\n    const buttonNC = p5.createButton(\"Layer\");\n    buttonNC.position(p5.width * 0.32, p5.height * 0.9);\n    p5.noFill();\n    buttonNC.mousePressed(this.createNewLayer.bind(this)); //button Track\n\n    let buttonShape = p5.createButton(\"Track\");\n    buttonShape.position(p5.width * 0.42, p5.height * 0.9);\n    buttonShape.mousePressed(this.selectShape.bind(this)); //buttonShape.mouseReleased(console.log(\"ciao\"));\n    //button Track\n\n    buttonShape = p5.createButton(\"Shape\");\n    buttonShape.position(p5.width * 0.52, p5.height * 0.9);\n    buttonShape.mousePressed(this.changeShape.bind(this));\n    const buttonRotate = p5.createButton(\"Rotate\");\n    buttonRotate.position(p5.width * 0.62, p5.height * 0.9);\n    buttonRotate.mousePressed(this.rotateShape.bind(this));\n  }\n\n  draw(p5) {\n    p5.fill(255);\n    p5.ellipse(this.canvasWidth / 2, this.canvasHeight / 2, this.firstLayerLandW, this.firstLayerLandW); //if (layerNumber == 2) {\n    //  p5.stroke(195, 195, 195);\n    //}\n    //DRAW NODES\n\n    let angle = p5.TWO_PI / 4 * 3;\n    let step = p5.TWO_PI / this.nGrain;\n    p5.push();\n    let grainX;\n    let grainY;\n\n    for (let i = 0; i < this.nGrain; i++) {\n      grainX = this.canvasWidth / 2 + p5.cos(angle) * (this.firstLayerLandW / 2);\n      grainY = this.canvasHeight / 2 + p5.sin(angle) * (this.firstLayerLandW / 2); //var grains = p5.createVector(grainX, grainY);\n      //vertices.p5.push(grains);\n\n      p5.strokeWeight(10);\n      p5.point(grainX, grainY);\n      angle += step;\n    }\n\n    p5.pop(); //END NODES\n    //Custom Shape Mode\n\n    if (this.instrumentMode == 7) {\n      p5.push();\n      let selGrainX = this.canvasWidth / 2 + p5.cos(angle + step * this.currentGrain) * (this.firstLayerLandW / 2);\n      let selGrainY = this.canvasHeight / 2 + p5.sin(angle + step * this.currentGrain) * (this.firstLayerLandW / 2);\n      let grains = p5.createVector(grainX, grainY); //vertices.p5.push(grains);\n\n      p5.strokeWeight(10);\n      p5.stroke(\"red\");\n      p5.point(selGrainX, selGrainY);\n      p5.pop();\n    } //vert is defined as vert=createVector(n1,n2,...,nn) with nn --number/id of the grain\n    //POLYGON_SPEC, defining\n\n\n    p5.push();\n\n    const polygon_spec = (windowWidth, windowHeight, radius, vert) => {\n      let angle = p5.TWO_PI / this.nGrain; //draws first layer shapes\n\n      p5.beginShape();\n\n      for (let i = 0; i <= vert.length; i++) {\n        let corr_node = vert[i];\n        let count = 0;\n\n        for (let a = 0; a < p5.TWO_PI; a += angle) {\n          if (count == corr_node) {\n            let sx = windowWidth + p5.cos(a - p5.TWO_PI / 4) * radius;\n            let sy = windowHeight + p5.sin(a - p5.TWO_PI / 4) * radius;\n            p5.vertex(sx, sy);\n          }\n\n          count++;\n        }\n      }\n\n      p5.endShape(p5.CLOSE);\n    };\n\n    p5.pop();\n\n    if (this.selectedShape > this.maxNumShapes) {\n      this.selectedShape = 1;\n    } //it creates all the tracks\n\n\n    for (let i = 1; i <= this.maxNumShapes; i++) {\n      p5.push();\n      p5.translate(p5.width * 0.5, p5.height * 0.5);\n      p5.colorMode(p5.RGB);\n      p5.fill(i * 50, i * 20, i * 10, 100);\n\n      if (this.selectedShape == i) {\n        p5.strokeWeight(3);\n      }\n\n      p5.rotate(p5.TWO_PI * this.rot1[i - 1] / this.nGrain); // TO BE FIXED! the circular array is useless, we can use polygon_array_ALL as a database of all the possible shapes. Then, with shp1, shp2, etc. we point the shape we need. For now i set it to polygon_array_ALL[0];\n\n      polygon_spec(0, 0, this.firstLayerLandW / 2, this.polygon_array[this.shp1[i - 1]]);\n      p5.pop();\n    }\n\n    if (this.layerNumber == 2) {\n      p5.fill(250, 250, 250, 70);\n      p5.stroke(0);\n      p5.ellipse(this.canvasWidth / 2, this.canvasHeight / 2, 600, 600); //Grains for Layer 2\n\n      p5.push();\n      let angle2 = p5.TWO_PI / 4 * 3;\n      let step2 = p5.TWO_PI / this.nGrain;\n\n      for (let j = 0; j < this.nGrain; j++) {\n        let grainX2 = this.canvasWidth / 2 + p5.cos(angle2) * 300; //320 effects how much bigger the second circle is should be half the width and height of the elipse\n\n        let grainY2 = this.canvasHeight / 2 + p5.sin(angle2) * 300;\n        let grains2 = p5.createVector(grainX2, grainY2); //vertices.push(grains2);\n\n        p5.strokeWeight(10);\n        p5.point(grainX2, grainY2);\n        angle2 += step2;\n      }\n\n      p5.pop(); //POLYGON_SPEC2, defining SECOND LAYERRRRRR!\n\n      p5.push();\n\n      const polygon_spec2 = (windowWidth, windowHeight, radius, vert) => {\n        let angle = p5.TWO_PI / this.nGrain; //draws first layer shapes\n\n        p5.beginShape();\n\n        for (let i = 0; i <= vert.length; i++) {\n          let corr_node = vert[i];\n          let count = 0;\n\n          for (let a = 0; a < p5.TWO_PI; a += angle) {\n            if (count == corr_node) {\n              let sx = this.canvasWidth + p5.cos(a - p5.TWO_PI / 4) * radius;\n              let sy = this.canvasHeight + p5.sin(a - p5.TWO_PI / 4) * radius;\n              p5.vertex(sx, sy);\n            }\n\n            count++;\n          }\n        }\n\n        p5.endShape(p5.CLOSE);\n      };\n\n      p5.pop();\n\n      if (this.selectedShape2 > this.maxNumShape2) {\n        this.selectedShape2 = 1;\n      } //it creates all the tracks\n\n\n      for (let i = 1; i <= this.maxNumShape2; i++) {\n        p5.push();\n        p5.translate(p5.width * 0.5, p5.height * 0.5);\n        p5.colorMode(p5.RGB);\n        p5.fill(i * 50, i * 20, i * 10, 100);\n\n        if (this.selectedShape2 == i) {\n          p5.strokeWeight(3);\n        }\n\n        p5.rotate(p5.TWO_PI * this.rot2[i - 1] / this.nGrain); // TO BE FIXED! the circular array is useless, we can use polygon_array_ALL as a database of all the possible shapes. Then, with shp1, shp2, etc. we point the shape we need. For now i set it to polygon_array_ALL[0];\n\n        polygon_spec2(0, 0, this.firstLayerLandW / 2, this.polygon_array2[this.shp2[i - 1]]);\n        p5.pop();\n      }\n    }\n  }\n\n  encoderInc() {\n    //INC LAYER SELECTION MODE\n    if (this.instrumentMode == 1 && this.layerNumber == 1) {\n      this.layerNumber = 2;\n    } else if (this.instrumentMode == 1 && this.layerNumber == 2) {\n      this.layerNumber = 1;\n    } //INC TRACK SELECTION MODE\n\n\n    if (this.instrumentMode == 2 && this.selectedShape != 0) {\n      //change track\n      this.selectedShape++;\n    } //INC CHANGE SHAPE MODE\n\n\n    if (this.instrumentMode == 3 && this.shp1[this.selectedShape - 1] != this.polygon_array.length) {\n      //this.polygon_array_ALL[this.selectedShape-1][kindOfShape]=this.polygon_array_ALL[this.selectedShape-1][kindOfShape++];\n      this.shp1[this.selectedShape - 1] = this.shp1[this.selectedShape - 1] + 1;\n    }\n\n    if (this.instrumentMode == 3 && this.shp1[this.selectedShape - 1] == this.polygon_array.length) {\n      this.shp1[this.selectedShape - 1] = 0;\n    } //INC CUSTOM SHAPE MODE\n\n\n    if (this.instrumentMode == 7) {\n      if (this.currentGrain == this.nGrain - 1) {\n        this.currentGrain = 0;\n      } else {\n        this.currentGrain++;\n      }\n    } //INC CHANGE ROTATION MODE\n\n\n    if (this.instrumentMode == 4 && this.selectedShape != 0) {\n      //rotate the selected shape\n      this.rot1[this.selectedShape - 1] = this.rot1[this.selectedShape - 1] + 1;\n    }\n  }\n\n  encoderDec() {\n    //LAYER SELECTION MODE\n    if (this.instrumentMode == 1 && this.layerNumber == 1) {\n      this.layerNumber = 2;\n    } else if (this.instrumentMode == 1 && this.layerNumber == 2) {\n      this.layerNumber = 1;\n    } //TRACK SELECTION MODE\n\n\n    if (this.instrumentMode == 2 && this.selectedShape != (0 || 1)) {\n      this.selectedShape--;\n    } else if (this.instrumentMode == 2 && this.selectedShape == 1) {\n      this.selectedShape = this.maxNumShapes;\n    } //then CHANGE SHAPE MODE\n\n\n    if (this.instrumentMode == 3 && this.shp1[this.selectedShape - 1] != 0) {\n      this.shp1[this.selectedShape - 1] = this.shp1[this.selectedShape - 1] - 1;\n    } else if (this.instrumentMode == 3 && this.shp1[this.selectedShape - 1] == 0) {\n      this.shp1[this.selectedShape - 1] = this.polygon_array.length - 1;\n    } //CUSTOM SHAPE MODE\n\n\n    if (this.instrumentMode == 7) {\n      if (this.currentGrain == 0) {\n        this.currentGrain = this.nGrain - 1;\n      } else {\n        this.currentGrain--;\n      }\n    } //the CHANGE ROTATION MODE\n\n\n    if (this.instrumentMode == 4 && this.selectedShape != 0) {\n      this.rot1[this.selectedShape - 1] = this.rot1[this.selectedShape - 1] - 1;\n    }\n  }\n\n  encoderButt() {\n    if (this.instrumentMode == 7) {\n      if (this.polygon_array_c.includes(this.currentGrain)) {\n        for (let i = 0; i < this.polygon_array_c.length; i++) {\n          if (this.polygon_array_c[i] === this.currentGrain) {\n            this.polygon_array_c.splice(i, 1);\n          }\n        }\n      } else {\n        this.polygon_array_c.push(this.currentGrain);\n      }\n\n      this.polygon_array_c.sort(function (a, b) {\n        return a - b;\n      });\n    }\n  }\n\n  deleteShape() {\n    if (this.instrumentMode == 7) {\n      this.instrumentMode = 2;\n    }\n\n    this.shp1.splice(this.selectedShape - 1, 1);\n    this.rot1.splice(this.selectedShape - 1, 1);\n    this.maxNumShapes--; //start from skratch\n\n    if (this.maxNumShapes == 0) {\n      this.instrumentMode = 0;\n    }\n\n    this.selectedShape = this.maxNumShapes;\n  } //CREATE NEW LAYER FUNCTION\n\n\n  createNewLayer() {\n    this.instrumentMode = 1; // myTimeout = setTimeout(function() {\n\n    this.layerNumber++; //, 2000);\n  } //TRACK SELECTION/ADD TRACK FUNCTION\n\n\n  selectShape() {\n    this.instrumentMode = 2; // we are in track_mode!\n\n    this.selectedShape = this.maxNumShapes; //if you press for 2 seconds you create a new track\n\n    if (this.instrumentMode != 0) {\n      setTimeout(() => {\n        this.maxNumShapes = this.maxNumShapes + 1;\n        this.updateArrays();\n      }, 2000);\n    }\n  } ///CHANGE SHAPE AND GO INTO CUSTOM SHAPE FUNCTION\n\n\n  changeShape() {\n    this.instrumentMode = 3; // we are in change_shape_mode!\n\n    const myTimeout = setTimeout(() => {\n      this.instrumentMode = 7;\n      this.maxNumShapes++;\n      this.numCustShapes++;\n      this.selectedShape = this.maxNumShapes;\n\n      if (this.numCustShapes > 0) {\n        //resets current grain to 0\n        this.currentGrain = 0;\n      }\n\n      this.polygon_array_c = new Array(); //splice(this.maxNumShapes, 0, this.polygon_array_c);\n\n      this.polygon_array.push(this.polygon_array_c);\n      this.shp1.push(this.polygon_array.length - 1);\n      this.updateArrays();\n    }, 2000);\n  } //ROTATE SHAPE FUNCTION\n\n\n  rotateShape() {\n    this.instrumentMode = 4; // we are in rotation_mode!\n  } //UPDATE ARRAYS\n\n\n  updateArrays() {\n    // this is the rotation array, containing all the rotation indexes for just the FIRST layer. Its length is equal to the maximum number of shapes created in the related layer.\n    this.rot1.push(0);\n\n    if (this.layerNumber == 2) {\n      this.rot2.push(0);\n    } //kind of shape index array relative to the first layer. here are stored the kind of shape of tracks. i set up this number to be 1,2,3...maxNumofShapes just to make the user distinguish between and avoid graphic overlap.\n\n\n    if (this.instrumentMode == 2) {\n      this.shp1.push(this.maxNumShapes - 1);\n    }\n\n    if (this.instrumentMode == 2 && this.layerNumber == 2) {\n      this.shp2.push(this.maxNumShape2 - 1);\n    }\n\n    this.selectedShape = this.maxNumShapes;\n    this.selectedShape2 = this.maxNumShape2;\n    /*if (instrumentMode == 7) {\n    this.shp1.push(polygon_array.length)\n    }*/\n  }\n\n}\n\nexport const MainSketch = new MainSketchClass();","map":{"version":3,"sources":["/Users/agnesepantaleone/Desktop/Drummachine/src/sketches/sketch.ts"],"names":["MainSketchClass","constructor","comboBox","canvasWidth","canvasHeight","instrumentMode","layerNumber","kindOfShape","selectedShape","selectedShape2","maxNumShapes","maxNumShape2","numCustShapes","circleLandW","clockCircleScaleSize","currentGrain","currentGrain2","nGrain","firstLayerLandW","rot1","Array","shp1","rot2","shp2","polygon_array","polygon_array_c","polygon_array2","initializeArrays","initializePolygonArrays","i","h","length","Math","round","setup","p5","canvasParentRef","createCanvas","width","height","parent","background","buttondx","createButton","position","buttonsx","buttonenc","mousePressed","encoderInc","bind","encoderDec","encoderButt","buttoncust","deleteShape","buttonNC","noFill","createNewLayer","buttonShape","selectShape","changeShape","buttonRotate","rotateShape","draw","fill","ellipse","angle","TWO_PI","step","push","grainX","grainY","cos","sin","strokeWeight","point","pop","selGrainX","selGrainY","grains","createVector","stroke","polygon_spec","windowWidth","windowHeight","radius","vert","beginShape","corr_node","count","a","sx","sy","vertex","endShape","CLOSE","translate","colorMode","RGB","rotate","angle2","step2","j","grainX2","grainY2","grains2","polygon_spec2","includes","splice","sort","b","setTimeout","updateArrays","myTimeout","MainSketch"],"mappings":"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","sourcesContent":["import * as P5 from \"p5\"\n\nexport interface P5Sketch {\n    setup(p5: P5, canvasParentRef: \"centralSquare\"): void\n    draw(p5: P5): void\n}\n\nclass MainSketchClass implements P5Sketch {\n    private comboBox = 0\n    private canvasWidth = 800\n    private canvasHeight = 600\n    private instrumentMode: number = 0\n    private layerNumber: number = 1\n    private kindOfShape: number = 0\n    private selectedShape: number = 0\n    private selectedShape2: number = 0\n    private maxNumShapes = 1\n    private maxNumShape2 = 2\n    private numCustShapes = 0\n    private circleLandW = 500\n    private clockCircleScaleSize = 1\n    private currentGrain = 0\n    private currentGrain2 = 0\n    private nGrain = 16\n    private firstLayerLandW = 500\n    private rot1 = new Array(1)\n    private shp1 = new Array(1)\n    private rot2 = new Array(2)\n    private shp2 = new Array(2)\n    private polygon_array = new Array(this.nGrain - 1)\n    private polygon_array_c = new Array() // custom polygon array\n    private polygon_array2 = new Array(this.nGrain - 1)\n\n    constructor() {\n        this.initializeArrays()\n        this.initializePolygonArrays()\n    }\n\n    private initializePolygonArrays() {\n        //LOOP TO GENERATE DIFFERENT SHAPES\n        for (let i = 2; i <= this.nGrain; i++) { //starts from 2 since we need a line as the simplest shape possible\n            this.polygon_array[i - 2] = new Array(i)\n            for (let h = 0; h < this.polygon_array[i - 2].length; h++) {\n                this.polygon_array[i - 2][h] = Math.round(this.nGrain * h / this.polygon_array[i - 2].length)\n            }\n        }\n\n        for (let i = 2; i <= this.nGrain; i++) { //starts from 2 p5.since we need a line as the simplest shape possible\n            this.polygon_array2[i - 2] = new Array(i)\n            for (let h = 0; h < this.polygon_array2[i - 2].length; h++) {\n                this.polygon_array2[i - 2][h] = Math.round(this.nGrain * h / this.polygon_array2[i - 2].length)\n            }\n        }\n    }\n\n    private initializeArrays() {\n        for (let i = 0; i < this.rot1.length; i++) {\n            this.rot1[i] = 0\n        }\n\n        for (let i = 0; i < this.rot2.length; i++) {\n            this.rot2[i] = 0\n        }\n\n        for (let i = 0; i < this.shp1.length; i++) {\n            this.shp1[i] = i\n        }\n\n        for (let i = 0; i < this.shp2.length; i++) {\n            this.shp2[i] = i\n        }\n    }\n\n    public setup(p5: P5, canvasParentRef: \"centralSquare\"): void {\n        p5.createCanvas(p5.width=this.canvasWidth, p5.height=this.canvasHeight).parent(canvasParentRef) // use parent to render canvas in this ref (without that p5 render this canvas outside your component)\n        \n        p5.background(100, 150, 100)\n\n        const buttondx = p5.createButton('+1')\n        buttondx.position(p5.width * 0.87, p5.height * 0.8)\n\n        const buttonsx = p5.createButton(\"-1\")\n        buttonsx.position(p5.width * 0.87 - 35, p5.height * 0.8)\n\n        const buttonenc = p5.createButton(\"Encoder Button\")\n        buttonenc.position(p5.width * 0.8, p5.height * 0.84)\n\n        buttondx.mousePressed(this.encoderInc.bind(this))\n        buttonsx.mousePressed(this.encoderDec.bind(this))\n        buttonenc.mousePressed(this.encoderButt.bind(this))\n\n        const buttoncust = p5.createButton(\"X\")\n        buttoncust.position(p5.width * 0.85, p5.height * 0.2)\n        buttoncust.mousePressed(this.deleteShape.bind(this))\n\n        //button new Circle\n        const buttonNC = p5.createButton(\"Layer\")\n        buttonNC.position(p5.width * 0.32, p5.height * 0.9)\n        p5.noFill()\n        buttonNC.mousePressed(this.createNewLayer.bind(this))\n\n        //button Track\n        let buttonShape = p5.createButton(\"Track\")\n        buttonShape.position(p5.width * 0.42, p5.height * 0.9)\n        buttonShape.mousePressed(this.selectShape.bind(this))\n\n        //buttonShape.mouseReleased(console.log(\"ciao\"));\n\n        //button Track\n        buttonShape = p5.createButton(\"Shape\")\n        buttonShape.position(p5.width * 0.52, p5.height * 0.9)\n        buttonShape.mousePressed(this.changeShape.bind(this))\n\n        const buttonRotate = p5.createButton(\"Rotate\")\n        buttonRotate.position(p5.width * 0.62, p5.height * 0.9)\n        buttonRotate.mousePressed(this.rotateShape.bind(this))\n    }\n\n    public draw(p5: P5): void {\n        p5.fill(255)\n        p5.ellipse(this.canvasWidth / 2, this.canvasHeight / 2, this.firstLayerLandW, this.firstLayerLandW)\n        //if (layerNumber == 2) {\n        //  p5.stroke(195, 195, 195);\n        //}\n        //DRAW NODES\n        let angle = (p5.TWO_PI / 4) * 3\n        let step = p5.TWO_PI / this.nGrain\n        p5.push()\n        let grainX\n        let grainY\n        for (let i = 0; i < this.nGrain; i++) {\n            grainX = this.canvasWidth / 2 + (p5.cos(angle) * (this.firstLayerLandW / 2))\n            grainY = this.canvasHeight / 2 + (p5.sin(angle) * (this.firstLayerLandW / 2))\n            //var grains = p5.createVector(grainX, grainY);\n            //vertices.p5.push(grains);\n            p5.strokeWeight(10)\n            p5.point(grainX, grainY)\n            angle += step\n        }\n\n        p5.pop()\n        //END NODES\n\n        //Custom Shape Mode\n        if (this.instrumentMode == 7) {\n            p5.push()\n            let selGrainX = this.canvasWidth / 2 + (p5.cos(angle + (step * this.currentGrain)) * (this.firstLayerLandW / 2))\n            let selGrainY = this.canvasHeight / 2 + (p5.sin(angle + (step * this.currentGrain)) * (this.firstLayerLandW / 2))\n            let grains = p5.createVector(grainX, grainY)\n            //vertices.p5.push(grains);\n            p5.strokeWeight(10)\n            p5.stroke(\"red\")\n            p5.point(selGrainX, selGrainY)\n            p5.pop()\n        }\n\n\n        //vert is defined as vert=createVector(n1,n2,...,nn) with nn --number/id of the grain\n\n        //POLYGON_SPEC, defining\n        p5.push()\n\n        const polygon_spec = (windowWidth: any, windowHeight: any, radius: any, vert: any) => {\n            let angle = p5.TWO_PI / this.nGrain\n\n            //draws first layer shapes\n            p5.beginShape()\n            for (let i = 0; i <= vert.length; i++) {\n                let corr_node = vert[i]\n                let count = 0\n\n                for (let a = 0; a < p5.TWO_PI; a += angle) {\n                    if (count == corr_node) {\n                        let sx = windowWidth + p5.cos(a - (p5.TWO_PI / 4)) * radius\n                        let sy = windowHeight + p5.sin(a - (p5.TWO_PI / 4)) * radius\n                        p5.vertex(sx, sy)\n                    }\n                    count++\n                }\n            }\n            p5.endShape(p5.CLOSE)\n        }\n\n        p5.pop()\n        if (this.selectedShape > this.maxNumShapes) {\n            this.selectedShape = 1\n        }\n\n        //it creates all the tracks\n\n        for (let i = 1; i <= this.maxNumShapes; i++) {\n            p5.push()\n            p5.translate(p5.width * 0.5, p5.height * 0.5)\n            p5.colorMode(p5.RGB)\n            p5.fill(i * 50, i * 20, i * 10, 100)\n\n            if (this.selectedShape == i) {\n                p5.strokeWeight(3)\n\n\n            }\n            p5.rotate((p5.TWO_PI) * this.rot1[i - 1] / this.nGrain)\n            // TO BE FIXED! the circular array is useless, we can use polygon_array_ALL as a database of all the possible shapes. Then, with shp1, shp2, etc. we point the shape we need. For now i set it to polygon_array_ALL[0];\n\n\n            polygon_spec(0, 0, (this.firstLayerLandW / 2), this.polygon_array[this.shp1[i - 1]])\n            p5.pop()\n        }\n\n        if (this.layerNumber == 2) {\n            p5.fill(250, 250, 250, 70)\n            p5.stroke(0)\n            p5.ellipse(this.canvasWidth / 2, this.canvasHeight / 2, 600, 600)\n\n\n            //Grains for Layer 2\n            p5.push()\n            let angle2 = (p5.TWO_PI / 4) * 3\n            let step2 = p5.TWO_PI / this.nGrain\n\n            for (let j = 0; j < this.nGrain; j++) {\n                let grainX2 = this.canvasWidth / 2 + (p5.cos(angle2) * 300) //320 effects how much bigger the second circle is should be half the width and height of the elipse\n                let grainY2 = this.canvasHeight / 2 + (p5.sin(angle2) * 300)\n                let grains2 = p5.createVector(grainX2, grainY2)\n                //vertices.push(grains2);\n                p5.strokeWeight(10)\n                p5.point(grainX2, grainY2)\n                angle2 += step2\n            }\n            p5.pop()\n\n            //POLYGON_SPEC2, defining SECOND LAYERRRRRR!\n            p5.push()\n\n            const polygon_spec2 = (windowWidth: any, windowHeight: any, radius: any, vert: any) => {\n                let angle = p5.TWO_PI / this.nGrain\n\n                //draws first layer shapes\n                p5.beginShape()\n\n                for (let i = 0; i <= vert.length; i++) {\n                    let corr_node = vert[i]\n                    let count = 0\n                    for (let a = 0; a < p5.TWO_PI; a += angle) {\n                        if (count == corr_node) {\n                            let sx = this.canvasWidth + p5.cos(a - (p5.TWO_PI / 4)) * radius\n                            let sy = this.canvasHeight + p5.sin(a - (p5.TWO_PI / 4)) * radius\n                            p5.vertex(sx, sy)\n                        }\n                        count++\n                    }\n                }\n\n                p5.endShape(p5.CLOSE)\n            }\n\n            p5.pop()\n            if (this.selectedShape2 > this.maxNumShape2) {\n                this.selectedShape2 = 1\n            }\n\n            //it creates all the tracks\n\n            for (let i = 1; i <= this.maxNumShape2; i++) {\n                p5.push()\n                p5.translate(p5.width * 0.5, p5.height * 0.5)\n                p5.colorMode(p5.RGB)\n                p5.fill(i * 50, i * 20, i * 10, 100)\n\n                if (this.selectedShape2 == i) {\n                    p5.strokeWeight(3)\n\n\n                }\n                p5.rotate((p5.TWO_PI) * this.rot2[i - 1] / this.nGrain)\n                // TO BE FIXED! the circular array is useless, we can use polygon_array_ALL as a database of all the possible shapes. Then, with shp1, shp2, etc. we point the shape we need. For now i set it to polygon_array_ALL[0];\n\n\n                polygon_spec2(0, 0, (this.firstLayerLandW / 2), this.polygon_array2[this.shp2[i - 1]])\n                p5.pop()\n\n            }\n        }\n    }\n\n    private encoderInc() {\n        //INC LAYER SELECTION MODE\n        if (this.instrumentMode == 1 && this.layerNumber == 1) {\n            this.layerNumber = 2\n\n        } else if (this.instrumentMode == 1 && this.layerNumber == 2) {\n            this.layerNumber = 1\n        }\n\n        //INC TRACK SELECTION MODE\n        if (this.instrumentMode == 2 && this.selectedShape != 0) {\n            //change track\n            this.selectedShape++\n        }\n\n\n        //INC CHANGE SHAPE MODE\n        if (this.instrumentMode == 3 && this.shp1[this.selectedShape - 1] != this.polygon_array.length) {\n            //this.polygon_array_ALL[this.selectedShape-1][kindOfShape]=this.polygon_array_ALL[this.selectedShape-1][kindOfShape++];\n            this.shp1[this.selectedShape - 1] = this.shp1[this.selectedShape - 1] + 1\n\n        }\n        if (this.instrumentMode == 3 && this.shp1[this.selectedShape - 1] == this.polygon_array.length) {\n            this.shp1[this.selectedShape - 1] = 0\n        }\n\n        //INC CUSTOM SHAPE MODE\n        if (this.instrumentMode == 7) {\n            if (this.currentGrain == this.nGrain - 1) {\n                this.currentGrain = 0\n            } else {\n                this.currentGrain++\n            }\n        }\n\n        //INC CHANGE ROTATION MODE\n        if (this.instrumentMode == 4 && this.selectedShape != 0) {\n            //rotate the selected shape\n            this.rot1[this.selectedShape - 1] = this.rot1[this.selectedShape - 1] + 1\n        }\n    }\n\n    private encoderDec() {\n        //LAYER SELECTION MODE\n        if (this.instrumentMode == 1 && this.layerNumber == 1) {\n            this.layerNumber = 2\n        } else if (this.instrumentMode == 1 && this.layerNumber == 2) {\n            this.layerNumber = 1\n\n        }\n\n        //TRACK SELECTION MODE\n        if (this.instrumentMode == 2 && this.selectedShape != (0 || 1)) {\n            this.selectedShape--\n        } else if (this.instrumentMode == 2 && this.selectedShape == 1) {\n            this.selectedShape = this.maxNumShapes\n        }\n\n        //then CHANGE SHAPE MODE\n        if (this.instrumentMode == 3 && this.shp1[this.selectedShape - 1] != 0) {\n            this.shp1[this.selectedShape - 1] = this.shp1[this.selectedShape - 1] - 1\n        } else if (this.instrumentMode == 3 && this.shp1[this.selectedShape - 1] == 0) {\n            this.shp1[this.selectedShape - 1] = this.polygon_array.length - 1\n        }\n\n\n        //CUSTOM SHAPE MODE\n        if (this.instrumentMode == 7) {\n            if (this.currentGrain == 0) {\n                this.currentGrain = this.nGrain - 1\n            } else {\n                this.currentGrain--\n            }\n\n        }\n\n        //the CHANGE ROTATION MODE\n        if (this.instrumentMode == 4 && this.selectedShape != 0) {\n            this.rot1[this.selectedShape - 1] = this.rot1[this.selectedShape - 1] - 1\n        }\n    }\n\n    private encoderButt() {\n        if (this.instrumentMode == 7) {\n            if (this.polygon_array_c.includes(this.currentGrain)) {\n                for (let i = 0; i < this.polygon_array_c.length; i++) {\n                    if (this.polygon_array_c[i] === this.currentGrain) {\n                        this.polygon_array_c.splice(i, 1)\n                    }\n                }\n            } else {\n                this.polygon_array_c.push(this.currentGrain)\n            }\n            this.polygon_array_c.sort(function(a, b) {\n                return a - b\n            })\n\n        }\n    }\n\n    public deleteShape() {\n        if (this.instrumentMode == 7) {\n            this.instrumentMode = 2\n        }\n        this.shp1.splice(this.selectedShape - 1, 1)\n        this.rot1.splice(this.selectedShape - 1, 1)\n        this.maxNumShapes--\n        //start from skratch\n        if (this.maxNumShapes == 0) {\n            this.instrumentMode = 0\n        }\n        this.selectedShape = this.maxNumShapes\n    }\n\n    //CREATE NEW LAYER FUNCTION\n    public createNewLayer() {\n        this.instrumentMode = 1\n\n        // myTimeout = setTimeout(function() {\n        this.layerNumber++\n\n        //, 2000);\n    }\n\n    //TRACK SELECTION/ADD TRACK FUNCTION\n    public selectShape() {\n        this.instrumentMode = 2 // we are in track_mode!\n        this.selectedShape = this.maxNumShapes\n        //if you press for 2 seconds you create a new track\n        if (this.instrumentMode != 0) {\n            setTimeout(() => {\n                this.maxNumShapes = this.maxNumShapes + 1\n                this.updateArrays()\n            }, 2000)\n        }\n    }\n\n    ///CHANGE SHAPE AND GO INTO CUSTOM SHAPE FUNCTION\n    public changeShape() {\n        this.instrumentMode = 3 // we are in change_shape_mode!\n        const myTimeout = setTimeout(() => {\n            this.instrumentMode = 7\n            this.maxNumShapes++\n            this.numCustShapes++\n            this.selectedShape = this.maxNumShapes\n\n            if (this.numCustShapes > 0) { //resets current grain to 0\n                this.currentGrain = 0\n            }\n            this.polygon_array_c = new Array()\n            //splice(this.maxNumShapes, 0, this.polygon_array_c);\n            this.polygon_array.push(this.polygon_array_c)\n            this.shp1.push(this.polygon_array.length - 1)\n            this.updateArrays()\n        }, 2000)\n    }\n\n    //ROTATE SHAPE FUNCTION\n    public rotateShape() {\n        this.instrumentMode = 4 // we are in rotation_mode!\n    }\n\n    //UPDATE ARRAYS\n    private updateArrays() {\n        // this is the rotation array, containing all the rotation indexes for just the FIRST layer. Its length is equal to the maximum number of shapes created in the related layer.\n        this.rot1.push(0)\n\n        if (this.layerNumber == 2) {\n            this.rot2.push(0)\n        }\n\n\n        //kind of shape index array relative to the first layer. here are stored the kind of shape of tracks. i set up this number to be 1,2,3...maxNumofShapes just to make the user distinguish between and avoid graphic overlap.\n\n        if (this.instrumentMode == 2) {\n            this.shp1.push(this.maxNumShapes - 1)\n        }\n\n        if (this.instrumentMode == 2 && this.layerNumber == 2) {\n            this.shp2.push(this.maxNumShape2 - 1)\n        }\n\n        this.selectedShape = this.maxNumShapes\n        this.selectedShape2 = this.maxNumShape2\n\n        /*if (instrumentMode == 7) {\n        this.shp1.push(polygon_array.length)\n        }*/\n    }\n}\n\n\nexport const MainSketch = new MainSketchClass()"]},"metadata":{},"sourceType":"module"}