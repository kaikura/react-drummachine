{"ast":null,"code":"class MainSketchClass {\n  // custom polygon array\n  constructor() {\n    this.myTimeout = void 0;\n    this.comboBox = 0;\n    this.canvasWidth = 800;\n    this.canvasHeight = 600;\n    this.instrumentMode = 0;\n    this.layerNumber = 1;\n    this.kindOfShape = 0;\n    this.selectedShape = 0;\n    this.selectedShape2 = 0;\n    this.maxNumShapes = 1;\n    this.maxNumShape2 = 2;\n    this.numCustShapes = 0;\n    this.circleLandW = 500;\n    this.clockCircleScaleSize = 1;\n    this.currentGrain = 0;\n    this.currentGrain2 = 0;\n    this.nGrain = 16;\n    this.firstLayerLandW = 500;\n    this.rot1 = new Array(1);\n    this.shp1 = new Array(1);\n    this.rot2 = new Array(2);\n    this.shp2 = new Array(2);\n    this.polygon_array = new Array(this.nGrain - 1);\n    this.polygon_array_c = new Array();\n    this.polygon_array2 = new Array(this.nGrain - 1);\n    this.initializeArrays();\n    this.initializePolygonArrays();\n  } //public assignNumGrain() {\n  //this.nGrain=Component.numberGrains.value()\n  //}\n\n\n  initializePolygonArrays() {\n    //LOOP TO GENERATE DIFFERENT SHAPES\n    for (let i = 2; i <= this.nGrain; i++) {\n      //starts from 2 since we need a line as the simplest shape possible\n      this.polygon_array[i - 2] = new Array(i);\n\n      for (let h = 0; h < this.polygon_array[i - 2].length; h++) {\n        this.polygon_array[i - 2][h] = Math.round(this.nGrain * h / this.polygon_array[i - 2].length);\n      }\n    }\n\n    for (let i = 2; i <= this.nGrain; i++) {\n      //starts from 2 p5.since we need a line as the simplest shape possible\n      this.polygon_array2[i - 2] = new Array(i);\n\n      for (let h = 0; h < this.polygon_array2[i - 2].length; h++) {\n        this.polygon_array2[i - 2][h] = Math.round(this.nGrain * h / this.polygon_array2[i - 2].length);\n      }\n    }\n  }\n\n  initializeArrays() {\n    for (let i = 0; i < this.rot1.length; i++) {\n      this.rot1[i] = 0;\n    }\n\n    for (let i = 0; i < this.rot2.length; i++) {\n      this.rot2[i] = 0;\n    }\n\n    for (let i = 0; i < this.shp1.length; i++) {\n      this.shp1[i] = i;\n    }\n\n    for (let i = 0; i < this.shp2.length; i++) {\n      this.shp2[i] = i;\n    }\n  }\n\n  setup(p5, canvasParentRef) {\n    p5.createCanvas(p5.width = this.canvasWidth, p5.height = this.canvasHeight).parent(canvasParentRef); // use parent to render canvas in this ref (without that p5 render this canvas outside your component)\n    //p5.background(100, 150, 100)\n\n    const buttondx = p5.createButton('+1');\n    buttondx.position(p5.width * 0.87, p5.height * 0.8);\n    const buttonsx = p5.createButton(\"-1\");\n    buttonsx.position(p5.width * 0.87 - 35, p5.height * 0.8);\n    const buttonenc = p5.createButton(\"Encoder Button\");\n    buttonenc.position(p5.width * 0.8, p5.height * 0.84);\n    buttondx.mousePressed(this.encoderInc.bind(this));\n    buttonsx.mousePressed(this.encoderDec.bind(this));\n    buttonenc.mousePressed(this.encoderButt.bind(this));\n    const buttoncust = p5.createButton(\"X\");\n    buttoncust.position(p5.width * 0.85, p5.height * 0.2);\n    buttoncust.mousePressed(this.deleteShape.bind(this)); //button new Circle\n\n    const buttonNC = p5.createButton(\"Layer\");\n    buttonNC.position(p5.width * 0.32, p5.height * 0.9);\n    p5.noFill();\n    buttonNC.mousePressed(this.createNewLayer.bind(this)); //button Track\n\n    let buttonShape = p5.createButton(\"Track\");\n    buttonShape.position(p5.width * 0.42, p5.height * 0.9);\n    buttonShape.mousePressed(this.selectShape.bind(this)); //buttonShape.mouseReleased(console.log(\"ciao\"));\n    //button Track\n\n    buttonShape = p5.createButton(\"Shape\");\n    buttonShape.position(p5.width * 0.52, p5.height * 0.9);\n    buttonShape.mousePressed(this.changeShape.bind(this));\n    const buttonRotate = p5.createButton(\"Rotate\");\n    buttonRotate.position(p5.width * 0.62, p5.height * 0.9);\n    buttonRotate.mousePressed(this.rotateShape.bind(this));\n  }\n\n  draw(p5) {\n    p5.fill(255);\n    p5.ellipse(this.canvasWidth / 2, this.canvasHeight / 2, this.firstLayerLandW, this.firstLayerLandW); //if (layerNumber == 2) {\n    //  p5.stroke(195, 195, 195);\n    //}\n    //DRAW NODES\n\n    let angle = p5.TWO_PI / 4 * 3;\n    let step = p5.TWO_PI / this.nGrain;\n    p5.push();\n    let grainX;\n    let grainY;\n\n    for (let i = 0; i < this.nGrain; i++) {\n      grainX = this.canvasWidth / 2 + p5.cos(angle) * (this.firstLayerLandW / 2);\n      grainY = this.canvasHeight / 2 + p5.sin(angle) * (this.firstLayerLandW / 2); //var grains = p5.createVector(grainX, grainY);\n      //vertices.p5.push(grains);\n\n      p5.strokeWeight(10);\n      p5.point(grainX, grainY);\n      angle += step;\n    }\n\n    p5.pop(); //END NODES\n    //Custom Shape Mode\n\n    if (this.instrumentMode == 7 && this.layerNumber == 1) {\n      p5.push();\n      let selGrainX = this.canvasWidth / 2 + p5.cos(angle + step * this.currentGrain) * (this.firstLayerLandW / 2);\n      let selGrainY = this.canvasHeight / 2 + p5.sin(angle + step * this.currentGrain) * (this.firstLayerLandW / 2);\n      let grains = p5.createVector(grainX, grainY); //vertices.p5.push(grains);\n\n      p5.strokeWeight(10);\n      p5.stroke(\"red\");\n      p5.point(selGrainX, selGrainY);\n      p5.pop();\n    } //vert is defined as vert=createVector(n1,n2,...,nn) with nn --number/id of the grain\n    //POLYGON_SPEC, defining\n\n\n    p5.push();\n\n    const polygon_spec = (windowWidth, windowHeight, radius, vert) => {\n      let angle = p5.TWO_PI / this.nGrain; //draws first layer shapes\n\n      p5.beginShape();\n\n      for (let i = 0; i <= vert.length; i++) {\n        let corr_node = vert[i];\n        let count = 0;\n\n        for (let a = 0; a < p5.TWO_PI; a += angle) {\n          if (count == corr_node) {\n            let sx = windowWidth + p5.cos(a - p5.TWO_PI / 4) * radius;\n            let sy = windowHeight + p5.sin(a - p5.TWO_PI / 4) * radius;\n            p5.vertex(sx, sy);\n          }\n\n          count++;\n        }\n      }\n\n      p5.endShape(p5.CLOSE);\n    };\n\n    p5.pop();\n\n    if (this.selectedShape > this.maxNumShapes) {\n      this.selectedShape = 1;\n    } //it creates all the tracks\n\n\n    for (let i = 1; i <= this.maxNumShapes; i++) {\n      p5.push();\n      p5.translate(p5.width * 0.5, p5.height * 0.5);\n      p5.colorMode(p5.RGB);\n      p5.fill(i * 50, i * 20, i * 10, 100);\n\n      if (this.selectedShape == i) {\n        p5.strokeWeight(3);\n      }\n\n      p5.rotate(p5.TWO_PI * this.rot1[i - 1] / this.nGrain); // TO BE FIXED! the circular array is useless, we can use polygon_array_ALL as a database of all the possible shapes. Then, with shp1, shp2, etc. we point the shape we need. For now i set it to polygon_array_ALL[0];\n\n      polygon_spec(0, 0, this.firstLayerLandW / 2, this.polygon_array[this.shp1[i - 1]]);\n      p5.pop();\n    }\n\n    if (this.layerNumber == 2) {\n      p5.fill(250, 250, 250, 70);\n      p5.stroke(0);\n      p5.ellipse(this.canvasWidth / 2, this.canvasHeight / 2, this.circleLandW, this.circleLandW); //CLOCK RING\n\n      p5.noFill();\n      p5.strokeWeight(17);\n      p5.stroke(250, 250, 250, 70);\n      p5.ellipse(this.canvasWidth / 2, this.canvasHeight / 2, 550 * this.clockCircleScaleSize, 550 * this.clockCircleScaleSize);\n      p5.strokeWeight(1);\n      p5.stroke(.5);\n      p5.ellipse(this.canvasWidth / 2, this.canvasHeight / 2, 570 * this.clockCircleScaleSize, 570 * this.clockCircleScaleSize);\n      p5.ellipse(this.canvasWidth / 2, this.canvasHeight / 2, 560 * this.clockCircleScaleSize, 560 * this.clockCircleScaleSize);\n      p5.ellipse(this.canvasWidth / 2, this.canvasHeight / 2, 550 * this.clockCircleScaleSize, 550 * this.clockCircleScaleSize);\n      p5.ellipse(this.canvasWidth / 2, this.canvasHeight / 2, 540 * this.clockCircleScaleSize, 540 * this.clockCircleScaleSize);\n      p5.ellipse(this.canvasWidth / 2, this.canvasHeight / 2, 530 * this.clockCircleScaleSize, 530 * this.clockCircleScaleSize); //CLOCK RING \"GRAINS\"\n\n      p5.push();\n      let angle2 = p5.TWO_PI / 4 * 3;\n      let step2 = p5.TWO_PI / this.nGrain;\n\n      for (let j = 0; j < this.nGrain; j++) {\n        var grainX2 = this.canvasWidth / 2 + p5.cos(angle2) * 266 * this.clockCircleScaleSize; //320 effects how much bigger the second circle is should be half the width and height of the elipse\n\n        var grainY2 = this.canvasHeight / 2 + p5.sin(angle2) * 266 * this.clockCircleScaleSize;\n        p5.strokeWeight(3);\n        p5.line(grainX2, grainY2, grainX2 + p5.cos(angle2) * 18, grainY2 + p5.sin(angle2) * 18);\n        angle2 += step2;\n      }\n\n      p5.pop(); //Grains for Layer 2\n\n      p5.push();\n\n      for (let j = 0; j < this.nGrain; j++) {\n        let grainX2 = this.canvasWidth / 2 + p5.cos(angle2) * 250; //320 effects how much bigger the second circle is should be half the width and height of the elipse\n\n        let grainY2 = this.canvasHeight / 2 + p5.sin(angle2) * 250;\n        let grains2 = p5.createVector(grainX2, grainY2); //vertices.push(grains2);\n\n        p5.strokeWeight(10);\n        p5.point(grainX2, grainY2);\n        angle2 += step2;\n      }\n\n      p5.pop(); //Custom Shape Mode \n\n      if (this.instrumentMode == 7 && this.layerNumber == 2) {\n        p5.push();\n        let grainX2 = this.canvasWidth / 2 + p5.cos(angle2) * 300; //320 effects how much bigger the second circle is should be half the width and height of the elipse\n\n        let grainY2 = this.canvasHeight / 2 + p5.sin(angle2) * 300;\n        let selGrainX2 = this.canvasWidth / 2 + p5.cos(angle + step * this.currentGrain) * (this.firstLayerLandW / 2);\n        let selGrainY2 = this.canvasHeight / 2 + p5.sin(angle + step * this.currentGrain) * (this.firstLayerLandW / 2);\n        let grains = p5.createVector(grainX2, grainY2); //vertices.p5.push(grains);\n\n        p5.strokeWeight(10);\n        p5.stroke(\"red\");\n        p5.point(selGrainX2, selGrainY2);\n        p5.pop();\n      } //POLYGON_SPEC2, defining SECOND LAYERRRRRR!\n\n\n      p5.push();\n\n      const polygon_spec2 = (windowWidth, windowHeight, radius, vert) => {\n        let angle = p5.TWO_PI / this.nGrain; //draws first layer shapes\n\n        p5.beginShape();\n\n        for (let i = 0; i <= vert.length; i++) {\n          let corr_node = vert[i];\n          let count = 0;\n\n          for (let a = 0; a < p5.TWO_PI; a += angle) {\n            if (count == corr_node) {\n              let sx = this.canvasWidth + p5.cos(a - p5.TWO_PI / 4) * radius;\n              let sy = this.canvasHeight + p5.sin(a - p5.TWO_PI / 4) * radius;\n              p5.vertex(sx, sy);\n            }\n\n            count++;\n          }\n        }\n\n        p5.endShape(p5.CLOSE);\n      };\n\n      p5.pop();\n\n      if (this.selectedShape2 > this.maxNumShape2) {\n        this.selectedShape2 = 1;\n      } //it creates all the tracks\n\n\n      for (let i = 1; i <= this.maxNumShape2; i++) {\n        p5.push();\n        p5.translate(p5.width * 0.5, p5.height * 0.5);\n        p5.colorMode(p5.RGB);\n        p5.fill(i * 50, i * 20, i * 10, 100);\n\n        if (this.selectedShape2 == i) {\n          p5.strokeWeight(3);\n        }\n\n        p5.rotate(p5.TWO_PI * this.rot2[i - 1] / this.nGrain); // TO BE FIXED! the circular array is useless, we can use polygon_array_ALL as a database of all the possible shapes. Then, with shp1, shp2, etc. we point the shape we need. For now i set it to polygon_array_ALL[0];\n\n        polygon_spec2(0, 0, this.firstLayerLandW / 2, this.polygon_array2[this.shp2[i - 1]]);\n        p5.pop();\n      }\n    }\n  }\n\n  encoderInc() {\n    //INC LAYER SELECTION MODE\n    if (this.instrumentMode == 1 && this.layerNumber == 1) {\n      this.layerNumber = 2;\n    } else if (this.instrumentMode == 1 && this.layerNumber == 2) {\n      this.layerNumber = 1;\n    } //INC TRACK SELECTION MODE\n\n\n    if (this.instrumentMode == 2 && this.selectedShape != 0 && this.layerNumber == 2) {\n      //change track\n      this.selectedShape++;\n    }\n\n    if (this.instrumentMode == 2 && this.layerNumber == 2) {\n      this.selectedShape = 0;\n      this.selectedShape2++;\n    } //INC CHANGE SHAPE MODE\n\n\n    if (this.layerNumber == 1 && this.instrumentMode == 3 && this.shp1[this.selectedShape - 1] != this.polygon_array.length) {\n      //this.polygon_array_ALL[this.selectedShape-1][kindOfShape]=this.polygon_array_ALL[this.selectedShape-1][kindOfShape++];\n      this.shp1[this.selectedShape - 1] = this.shp1[this.selectedShape - 1] + 1;\n    }\n\n    if (this.layerNumber == 1 && this.instrumentMode == 3 && this.shp1[this.selectedShape - 1] == this.polygon_array.length) {\n      this.shp1[this.selectedShape - 1] = 0;\n    }\n\n    if (this.layerNumber == 2 && this.instrumentMode == 3 && this.shp2[this.selectedShape2 - 1] != this.polygon_array2.length) {\n      //this.polygon_array_ALL[this.selectedShape-1][kindOfShape]=this.polygon_array_ALL[this.selectedShape-1][kindOfShape++];\n      this.shp2[this.selectedShape2 - 1] = this.shp2[this.selectedShape2 - 1] + 1;\n    }\n\n    if (this.layerNumber == 2 && this.instrumentMode == 3 && this.shp2[this.selectedShape2 - 1] == this.polygon_array2.length) {\n      this.shp2[this.selectedShape2 - 1] = 0;\n    } //INC CUSTOM SHAPE MODE\n\n\n    if (this.layerNumber == 1 && this.instrumentMode == 7) {\n      if (this.currentGrain == this.nGrain - 1) {\n        this.currentGrain = 0;\n      } else {\n        this.currentGrain++;\n      }\n    }\n\n    if (this.layerNumber == 2 && this.instrumentMode == 7) {\n      if (this.currentGrain2 == this.nGrain - 1) {\n        this.currentGrain2 = 0;\n      } else {\n        this.currentGrain2++;\n      }\n    } //INC CHANGE ROTATION MODE\n\n\n    if (this.layerNumber == 1 && this.instrumentMode == 4 && this.selectedShape != 0) {\n      //rotate the selected shape\n      this.rot1[this.selectedShape - 1] = this.rot1[this.selectedShape - 1] + 1;\n    }\n\n    if (this.layerNumber == 2 && this.instrumentMode == 4 && this.selectedShape != 0) {\n      //rotate the selected shape\n      this.rot2[this.selectedShape2 - 1] = this.rot2[this.selectedShape2 - 1] + 1;\n    }\n  }\n\n  encoderDec() {\n    //LAYER SELECTION MODE\n    if (this.instrumentMode == 1 && this.layerNumber == 1) {\n      this.layerNumber = 2;\n    } else if (this.instrumentMode == 1 && this.layerNumber == 2) {\n      this.layerNumber = 1;\n    } //TRACK SELECTION MODE\n\n\n    if (this.layerNumber == 1 && this.instrumentMode == 2 && this.selectedShape != (0 || 1)) {\n      this.selectedShape--;\n    } else if (this.instrumentMode == 2 && this.selectedShape == 1) {\n      this.selectedShape = this.maxNumShapes;\n    }\n\n    if (this.layerNumber == 2 && this.instrumentMode == 2 && this.selectedShape2 != (0 || 1)) {\n      this.selectedShape2--;\n    } else if (this.instrumentMode == 2 && this.selectedShape2 == 1) {\n      this.selectedShape2 = this.maxNumShape2;\n    } //then CHANGE SHAPE MODE\n\n\n    if (this.layerNumber == 1 && this.instrumentMode == 3 && this.shp1[this.selectedShape - 1] != 0) {\n      this.shp1[this.selectedShape - 1] = this.shp1[this.selectedShape - 1] - 1;\n    } else if (this.instrumentMode == 3 && this.shp1[this.selectedShape - 1] == 0) {\n      this.shp1[this.selectedShape - 1] = this.polygon_array.length - 1;\n    }\n\n    if (this.layerNumber == 2 && this.instrumentMode == 3 && this.shp1[this.selectedShape - 1] != 0) {\n      this.shp2[this.selectedShape2 - 1] = this.shp2[this.selectedShape2 - 1] - 1;\n    } else if (this.instrumentMode == 3 && this.shp2[this.selectedShape2 - 1] == 0) {\n      this.shp2[this.selectedShape2 - 1] = this.polygon_array2.length - 1;\n    } //CUSTOM SHAPE MODE\n\n\n    if (this.layerNumber == 1 && this.instrumentMode == 7) {\n      if (this.currentGrain == 0) {\n        this.currentGrain = this.nGrain - 1;\n      } else {\n        this.currentGrain--;\n      }\n    }\n\n    if (this.layerNumber == 2 && this.instrumentMode == 7) {\n      if (this.currentGrain2 == 0) {\n        this.currentGrain2 = this.nGrain - 1;\n      } else {\n        this.currentGrain2--;\n      }\n    } //the CHANGE ROTATION MODE\n\n\n    if (this.layerNumber == 1 && this.instrumentMode == 4 && this.selectedShape != 0) {\n      this.rot1[this.selectedShape - 1] = this.rot1[this.selectedShape - 1] - 1;\n    }\n\n    if (this.layerNumber == 2 && this.instrumentMode == 4 && this.selectedShape != 0) {\n      this.rot2[this.selectedShape2 - 1] = this.rot2[this.selectedShape2 - 1] - 1;\n    }\n  }\n\n  encoderButt() {\n    if (this.layerNumber == 1 && this.instrumentMode == 7) {\n      if (this.polygon_array_c.includes(this.currentGrain)) {\n        for (let i = 0; i < this.polygon_array_c.length; i++) {\n          if (this.polygon_array_c[i] === this.currentGrain) {\n            this.polygon_array_c.splice(i, 1);\n          }\n        }\n      } else {\n        this.polygon_array_c.push(this.currentGrain);\n      }\n\n      this.polygon_array_c.sort(function (a, b) {\n        return a - b;\n      });\n    }\n\n    if (this.layerNumber == 2 && this.instrumentMode == 7) {\n      if (this.polygon_array_c.includes(this.currentGrain2)) {\n        for (let i = 0; i < this.polygon_array_c.length; i++) {\n          if (this.polygon_array_c[i] === this.currentGrain2) {\n            this.polygon_array_c.splice(i, 1);\n          }\n        }\n      } else {\n        this.polygon_array_c.push(this.currentGrain2);\n      }\n\n      this.polygon_array_c.sort(function (a, b) {\n        return a - b;\n      });\n    }\n  }\n\n  deleteShape() {\n    if (this.instrumentMode == 7) {\n      this.instrumentMode = 2;\n    }\n\n    if (this.layerNumber == 1) {\n      this.shp1.splice(this.selectedShape - 1, 1);\n      this.rot1.splice(this.selectedShape - 1, 1);\n      this.maxNumShapes--; //start from skratch\n\n      if (this.maxNumShapes == 0) {\n        this.instrumentMode = 0;\n      }\n\n      this.selectedShape = this.maxNumShapes;\n    }\n\n    if (this.layerNumber == 2) {\n      this.shp2.splice(this.selectedShape2 - 1, 1);\n      this.rot1.splice(this.selectedShape2 - 1, 1);\n      this.maxNumShape2--; //start from skratch\n\n      if (this.maxNumShape2 == 0) {\n        this.instrumentMode = 0;\n      }\n\n      this.selectedShape2 = this.maxNumShape2;\n    }\n  } //CREATE NEW LAYER FUNCTION\n\n\n  createNewLayer() {\n    this.instrumentMode = 1;\n    setTimeout(() => {\n      this.layerNumber++;\n    }, 2000);\n  } //TRACK SELECTION/ADD TRACK FUNCTION\n\n\n  selectShape() {\n    this.instrumentMode = 2; // we are in track_mode!\n\n    if (this.layerNumber == 1) {\n      this.selectedShape = this.maxNumShapes; //if you press for 2 seconds you create a new track\n\n      if (this.instrumentMode != 0) {\n        this.myTimeout = setTimeout(() => {\n          this.maxNumShapes = this.maxNumShapes + 1;\n          this.updateArrays();\n        }, 2000);\n      }\n    }\n\n    if (this.layerNumber == 2) {\n      this.selectedShape2 = this.maxNumShape2;\n\n      if (this.instrumentMode != 0) {\n        const myTimeout = setTimeout(() => {\n          this.maxNumShape2 = this.maxNumShape2 + 1;\n          this.updateArrays();\n        }, 2000);\n      }\n    }\n  } ///CHANGE SHAPE AND GO INTO CUSTOM SHAPE FUNCTION\n\n\n  changeShape() {\n    this.instrumentMode = 3; // we are in change_shape_mode!\n\n    setTimeout(() => {\n      if (this.layerNumber == 1) {\n        this.instrumentMode = 7;\n        this.maxNumShapes++;\n        this.numCustShapes++;\n        this.selectedShape = this.maxNumShapes;\n\n        if (this.numCustShapes > 0) {\n          //resets current grain to 0\n          this.currentGrain = 0;\n        }\n\n        this.polygon_array_c = new Array(); //splice(this.maxNumShapes, 0, this.polygon_array_c);\n\n        this.polygon_array.push(this.polygon_array_c);\n        this.shp1.push(this.polygon_array.length - 1);\n        this.updateArrays();\n      }\n\n      if (this.layerNumber == 2) {\n        this.instrumentMode = 7;\n        this.maxNumShape2++;\n        this.numCustShapes++;\n        this.selectedShape2 = this.maxNumShape2;\n\n        if (this.numCustShapes > 0) {\n          //resets current grain to 0 \n          this.currentGrain = 0;\n        }\n\n        this.polygon_array_c = new Array(); //splice(maxNumShapes, 0, polygon_array_c)\n\n        this.polygon_array2.push(this.polygon_array_c);\n        this.shp2.push(this.polygon_array2.length - 1);\n        this.updateArrays();\n      }\n    }, 2000);\n    clearTimeout(this.myTimeout);\n  } //ROTATE SHAPE FUNCTION\n\n\n  rotateShape() {\n    this.instrumentMode = 4; // we are in rotation_mode!\n  }\n\n  mouseReleased() {\n    clearTimeout(this.myTimeout);\n  } //UPDATE ARRAYS\n\n\n  updateArrays() {\n    // this is the rotation array, containing all the rotation indexes for just the FIRST layer. Its length is equal to the maximum number of shapes created in the related layer.\n    this.rot1.push(0);\n\n    if (this.layerNumber == 2) {\n      this.rot2.push(0);\n    } //kind of shape index array relative to the first layer. here are stored the kind of shape of tracks. i set up this number to be 1,2,3...maxNumofShapes just to make the user distinguish between and avoid graphic overlap.\n\n\n    if (this.instrumentMode == 2) {\n      this.shp1.push(this.maxNumShapes - 1);\n    }\n\n    if (this.instrumentMode == 2 && this.layerNumber == 2) {\n      this.shp2.push(this.maxNumShape2 - 1);\n    }\n\n    this.selectedShape = this.maxNumShapes;\n    this.selectedShape2 = this.maxNumShape2;\n    /*if (instrumentMode == 7) {\n    this.shp1.push(polygon_array.length)\n    }*/\n  }\n\n}\n\nexport const MainSketch = new MainSketchClass();","map":{"version":3,"sources":["/Users/agnesepantaleone/Desktop/Drummachine/src/sketches/sketch.ts"],"names":["MainSketchClass","constructor","myTimeout","comboBox","canvasWidth","canvasHeight","instrumentMode","layerNumber","kindOfShape","selectedShape","selectedShape2","maxNumShapes","maxNumShape2","numCustShapes","circleLandW","clockCircleScaleSize","currentGrain","currentGrain2","nGrain","firstLayerLandW","rot1","Array","shp1","rot2","shp2","polygon_array","polygon_array_c","polygon_array2","initializeArrays","initializePolygonArrays","i","h","length","Math","round","setup","p5","canvasParentRef","createCanvas","width","height","parent","buttondx","createButton","position","buttonsx","buttonenc","mousePressed","encoderInc","bind","encoderDec","encoderButt","buttoncust","deleteShape","buttonNC","noFill","createNewLayer","buttonShape","selectShape","changeShape","buttonRotate","rotateShape","draw","fill","ellipse","angle","TWO_PI","step","push","grainX","grainY","cos","sin","strokeWeight","point","pop","selGrainX","selGrainY","grains","createVector","stroke","polygon_spec","windowWidth","windowHeight","radius","vert","beginShape","corr_node","count","a","sx","sy","vertex","endShape","CLOSE","translate","colorMode","RGB","rotate","angle2","step2","j","grainX2","grainY2","line","grains2","selGrainX2","selGrainY2","polygon_spec2","includes","splice","sort","b","setTimeout","updateArrays","clearTimeout","mouseReleased","MainSketch"],"mappings":"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","sourcesContent":["import * as P5 from \"p5\"\nimport {render} from \"react-dom\"\nimport $ from \"jquery\"\nimport { ControlPanel } from \"src/components/control-panel/control-panel.component\"\nimport { RightPanel } from \"src/components/right-panel/right-panel.component\"\nimport { FooterPanel } from \"src/components/footer-panel/footer-panel.component\"\nimport { Component } from \"react\"\n\nexport interface P5Sketch {\n    setup(p5: P5, canvasParentRef: \"centralSquare\"): void\n    draw(p5: P5): void\n}\n\nclass MainSketchClass implements P5Sketch {\n    private myTimeout\n    private comboBox = 0\n    private canvasWidth = 800\n    private canvasHeight = 600\n    private instrumentMode: number = 0\n    private layerNumber: number = 1\n    private kindOfShape: number = 0\n    private selectedShape: number = 0\n    private selectedShape2: number = 0\n    private maxNumShapes = 1\n    private maxNumShape2 = 2\n    private numCustShapes = 0\n    private circleLandW = 500\n    private clockCircleScaleSize = 1\n    private currentGrain = 0\n    private currentGrain2 = 0\n    private nGrain = 16\n    private firstLayerLandW = 500\n    private rot1 = new Array(1)\n    private shp1 = new Array(1)\n    private rot2 = new Array(2)\n    private shp2 = new Array(2)\n    private polygon_array = new Array(this.nGrain - 1)\n    private polygon_array_c = new Array() // custom polygon array\n    private polygon_array2 = new Array(this.nGrain - 1)\n\n    constructor() {\n        this.initializeArrays()\n        this.initializePolygonArrays()\n    }\n\n    //public assignNumGrain() {\n        //this.nGrain=Component.numberGrains.value()\n    //}\n\n    private initializePolygonArrays() {\n        //LOOP TO GENERATE DIFFERENT SHAPES\n        for (let i = 2; i <= this.nGrain; i++) { //starts from 2 since we need a line as the simplest shape possible\n            this.polygon_array[i - 2] = new Array(i)\n            for (let h = 0; h < this.polygon_array[i - 2].length; h++) {\n                this.polygon_array[i - 2][h] = Math.round(this.nGrain * h / this.polygon_array[i - 2].length)\n            }\n        }\n\n        for (let i = 2; i <= this.nGrain; i++) { //starts from 2 p5.since we need a line as the simplest shape possible\n            this.polygon_array2[i - 2] = new Array(i)\n            for (let h = 0; h < this.polygon_array2[i - 2].length; h++) {\n                this.polygon_array2[i - 2][h] = Math.round(this.nGrain * h / this.polygon_array2[i - 2].length)\n            }\n        }\n    }\n\n    private initializeArrays() {\n        for (let i = 0; i < this.rot1.length; i++) {\n            this.rot1[i] = 0\n        }\n\n        for (let i = 0; i < this.rot2.length; i++) {\n            this.rot2[i] = 0\n        }\n\n        for (let i = 0; i < this.shp1.length; i++) {\n            this.shp1[i] = i\n        }\n\n        for (let i = 0; i < this.shp2.length; i++) {\n            this.shp2[i] = i\n        }\n    }\n\n    public setup(p5: P5, canvasParentRef: \"centralSquare\"): void {\n        p5.createCanvas(p5.width=this.canvasWidth, p5.height=this.canvasHeight).parent(canvasParentRef) // use parent to render canvas in this ref (without that p5 render this canvas outside your component)\n        \n        //p5.background(100, 150, 100)\n\n        const buttondx = p5.createButton('+1')\n        buttondx.position(p5.width * 0.87, p5.height * 0.8)\n\n        const buttonsx = p5.createButton(\"-1\")\n        buttonsx.position(p5.width * 0.87 - 35, p5.height * 0.8)\n\n        const buttonenc = p5.createButton(\"Encoder Button\")\n        buttonenc.position(p5.width * 0.8, p5.height * 0.84)\n\n        buttondx.mousePressed(this.encoderInc.bind(this))\n        buttonsx.mousePressed(this.encoderDec.bind(this))\n        buttonenc.mousePressed(this.encoderButt.bind(this))\n\n        const buttoncust = p5.createButton(\"X\")\n        buttoncust.position(p5.width * 0.85, p5.height * 0.2)\n        buttoncust.mousePressed(this.deleteShape.bind(this))\n\n        //button new Circle\n        const buttonNC = p5.createButton(\"Layer\")\n        buttonNC.position(p5.width * 0.32, p5.height * 0.9)\n        p5.noFill()\n        buttonNC.mousePressed(this.createNewLayer.bind(this))\n\n        //button Track\n        let buttonShape = p5.createButton(\"Track\")\n        buttonShape.position(p5.width * 0.42, p5.height * 0.9)\n        buttonShape.mousePressed(this.selectShape.bind(this))\n\n        //buttonShape.mouseReleased(console.log(\"ciao\"));\n\n        //button Track\n        buttonShape = p5.createButton(\"Shape\")\n        buttonShape.position(p5.width * 0.52, p5.height * 0.9)\n        buttonShape.mousePressed(this.changeShape.bind(this))\n\n        const buttonRotate = p5.createButton(\"Rotate\")\n        buttonRotate.position(p5.width * 0.62, p5.height * 0.9)\n        buttonRotate.mousePressed(this.rotateShape.bind(this))\n    }\n\n    public draw(p5: P5): void {\n        p5.fill(255)\n        p5.ellipse(this.canvasWidth / 2, this.canvasHeight / 2, this.firstLayerLandW, this.firstLayerLandW)\n        //if (layerNumber == 2) {\n        //  p5.stroke(195, 195, 195);\n        //}\n        //DRAW NODES\n        let angle = (p5.TWO_PI / 4) * 3\n        let step = p5.TWO_PI / this.nGrain\n        p5.push()\n        let grainX\n        let grainY\n        for (let i = 0; i < this.nGrain; i++) {\n            grainX = this.canvasWidth / 2 + (p5.cos(angle) * (this.firstLayerLandW / 2))\n            grainY = this.canvasHeight / 2 + (p5.sin(angle) * (this.firstLayerLandW / 2))\n            //var grains = p5.createVector(grainX, grainY);\n            //vertices.p5.push(grains);\n            p5.strokeWeight(10)\n            p5.point(grainX, grainY)\n            angle += step\n        }\n\n        p5.pop()\n        //END NODES\n\n        //Custom Shape Mode\n        if (this.instrumentMode == 7 && this.layerNumber==1) {\n            p5.push()\n            let selGrainX = this.canvasWidth / 2 + (p5.cos(angle + (step * this.currentGrain)) * (this.firstLayerLandW / 2))\n            let selGrainY = this.canvasHeight / 2 + (p5.sin(angle + (step * this.currentGrain)) * (this.firstLayerLandW / 2))\n            let grains = p5.createVector(grainX, grainY)\n            //vertices.p5.push(grains);\n            p5.strokeWeight(10)\n            p5.stroke(\"red\")\n            p5.point(selGrainX, selGrainY)\n            p5.pop()\n        }\n\n\n        //vert is defined as vert=createVector(n1,n2,...,nn) with nn --number/id of the grain\n\n        //POLYGON_SPEC, defining\n        p5.push()\n\n        const polygon_spec = (windowWidth: any, windowHeight: any, radius: any, vert: any) => {\n            let angle = p5.TWO_PI / this.nGrain\n\n            //draws first layer shapes\n            p5.beginShape()\n            for (let i = 0; i <= vert.length; i++) {\n                let corr_node = vert[i]\n                let count = 0\n\n                for (let a = 0; a < p5.TWO_PI; a += angle) {\n                    if (count == corr_node) {\n                        let sx = windowWidth + p5.cos(a - (p5.TWO_PI / 4)) * radius\n                        let sy = windowHeight + p5.sin(a - (p5.TWO_PI / 4)) * radius\n                        p5.vertex(sx, sy)\n                    }\n                    count++\n                }\n            }\n            p5.endShape(p5.CLOSE)\n        }\n\n        p5.pop()\n        if (this.selectedShape > this.maxNumShapes) {\n            this.selectedShape = 1\n        }\n\n        //it creates all the tracks\n\n        for (let i = 1; i <= this.maxNumShapes; i++) {\n            p5.push()\n            p5.translate(p5.width * 0.5, p5.height * 0.5)\n            p5.colorMode(p5.RGB)\n            p5.fill(i * 50, i * 20, i * 10, 100)\n\n            if (this.selectedShape == i) {\n                p5.strokeWeight(3)\n\n\n            }\n            p5.rotate((p5.TWO_PI) * this.rot1[i - 1] / this.nGrain)\n            // TO BE FIXED! the circular array is useless, we can use polygon_array_ALL as a database of all the possible shapes. Then, with shp1, shp2, etc. we point the shape we need. For now i set it to polygon_array_ALL[0];\n\n\n            polygon_spec(0, 0, (this.firstLayerLandW / 2), this.polygon_array[this.shp1[i - 1]])\n            p5.pop()\n        }\n\n        if (this.layerNumber == 2) {\n            p5.fill(250, 250, 250, 70)\n            p5.stroke(0)\n            p5.ellipse(this.canvasWidth / 2, this.canvasHeight / 2, this.circleLandW, this.circleLandW)\n\n            //CLOCK RING\n  p5.noFill()\n  p5.strokeWeight(17)\n  p5.stroke(250,250,250,70)\n  p5.ellipse(this.canvasWidth/2,this.canvasHeight/2, 550 *this.clockCircleScaleSize, 550 *this.clockCircleScaleSize)\n  p5.strokeWeight(1)\n\n  p5.stroke(.5)\n  p5.ellipse(this.canvasWidth/2,this.canvasHeight/2, 570 *this.clockCircleScaleSize, 570 *this.clockCircleScaleSize)\n  p5.ellipse(this.canvasWidth/2,this.canvasHeight/2, 560 *this.clockCircleScaleSize, 560 *this.clockCircleScaleSize)\n  p5.ellipse(this.canvasWidth/2,this.canvasHeight/2, 550 *this.clockCircleScaleSize, 550 *this.clockCircleScaleSize)\n  p5.ellipse(this.canvasWidth/2,this.canvasHeight/2, 540 *this.clockCircleScaleSize, 540 *this.clockCircleScaleSize)\n  p5.ellipse(this.canvasWidth/2,this.canvasHeight/2, 530 *this.clockCircleScaleSize, 530 *this.clockCircleScaleSize)\n\n  //CLOCK RING \"GRAINS\"\n  p5.push()\n  let angle2 = (p5.TWO_PI / 4) * 3\n  let step2 = p5.TWO_PI / this.nGrain\n\n  for (let j = 0; j < this.nGrain; j++) {\n    var grainX2 = this.canvasWidth/2 + (p5.cos(angle2) * 266 *this.clockCircleScaleSize) //320 effects how much bigger the second circle is should be half the width and height of the elipse\n    var grainY2 = this.canvasHeight/2 + (p5.sin(angle2) * 266 *this.clockCircleScaleSize)\n    p5.strokeWeight(3)\n    p5.line(grainX2, grainY2, grainX2 + (p5.cos(angle2)*18), grainY2 + (p5.sin(angle2)*18))\n    angle2 += step2\n  }\n  p5.pop()\n\n\n            //Grains for Layer 2\n            p5.push()\n\n            for (let j = 0; j < this.nGrain; j++) {\n                let grainX2 = this.canvasWidth / 2 + (p5.cos(angle2) * 250) //320 effects how much bigger the second circle is should be half the width and height of the elipse\n                let grainY2 = this.canvasHeight / 2 + (p5.sin(angle2) * 250)\n                let grains2 = p5.createVector(grainX2, grainY2)\n                //vertices.push(grains2);\n                p5.strokeWeight(10)\n                p5.point(grainX2, grainY2)\n                angle2 += step2\n            }\n            p5.pop()\n            //Custom Shape Mode \n            if (this.instrumentMode == 7 && this.layerNumber==2) {\n                p5.push()\n                let grainX2 = this.canvasWidth / 2 + (p5.cos(angle2) * 300) //320 effects how much bigger the second circle is should be half the width and height of the elipse\n                let grainY2 = this.canvasHeight / 2 + (p5.sin(angle2) * 300)\n                let selGrainX2 = this.canvasWidth / 2 + (p5.cos(angle + (step * this.currentGrain)) * (this.firstLayerLandW / 2))\n                let selGrainY2 = this.canvasHeight / 2 + (p5.sin(angle + (step * this.currentGrain)) * (this.firstLayerLandW / 2))\n                let grains = p5.createVector(grainX2, grainY2)\n                //vertices.p5.push(grains);\n                p5.strokeWeight(10)\n                p5.stroke(\"red\")\n                p5.point(selGrainX2, selGrainY2)\n                p5.pop()\n            }\n    \n\n            //POLYGON_SPEC2, defining SECOND LAYERRRRRR!\n            p5.push()\n\n            const polygon_spec2 = (windowWidth: any, windowHeight: any, radius: any, vert: any) => {\n                let angle = p5.TWO_PI / this.nGrain\n\n                //draws first layer shapes\n                p5.beginShape()\n\n                for (let i = 0; i <= vert.length; i++) {\n                    let corr_node = vert[i]\n                    let count = 0\n                    for (let a = 0; a < p5.TWO_PI; a += angle) {\n                        if (count == corr_node) {\n                            let sx = this.canvasWidth + p5.cos(a - (p5.TWO_PI / 4)) * radius\n                            let sy = this.canvasHeight + p5.sin(a - (p5.TWO_PI / 4)) * radius\n                            p5.vertex(sx, sy)\n                        }\n                        count++\n                    }\n                }\n\n                p5.endShape(p5.CLOSE)\n            }\n\n            p5.pop()\n            if (this.selectedShape2 > this.maxNumShape2) {\n                this.selectedShape2 = 1\n            }\n\n            //it creates all the tracks\n\n            for (let i = 1; i <= this.maxNumShape2; i++) {\n                p5.push()\n                p5.translate(p5.width * 0.5, p5.height * 0.5)\n                p5.colorMode(p5.RGB)\n                p5.fill(i * 50, i * 20, i * 10, 100)\n\n                if (this.selectedShape2 == i) {\n                    p5.strokeWeight(3)\n\n\n                }\n                p5.rotate((p5.TWO_PI) * this.rot2[i - 1] / this.nGrain)\n                // TO BE FIXED! the circular array is useless, we can use polygon_array_ALL as a database of all the possible shapes. Then, with shp1, shp2, etc. we point the shape we need. For now i set it to polygon_array_ALL[0];\n\n\n                polygon_spec2(0, 0, (this.firstLayerLandW / 2), this.polygon_array2[this.shp2[i - 1]])\n                p5.pop()\n\n            }\n        }\n    }\n\n    public encoderInc() {\n        //INC LAYER SELECTION MODE\n        if (this.instrumentMode == 1 && this.layerNumber == 1) {\n            this.layerNumber = 2\n\n        } else if (this.instrumentMode == 1 && this.layerNumber == 2) {\n            this.layerNumber = 1\n        }\n\n        //INC TRACK SELECTION MODE\n        if (this.instrumentMode == 2 && this.selectedShape != 0 && this.layerNumber==2) {\n            //change track\n            this.selectedShape++\n        }\n        if (this.instrumentMode == 2 && this.layerNumber ==2){\n            this.selectedShape = 0\n            this.selectedShape2++\n          }\n        \n\n\n        //INC CHANGE SHAPE MODE\n        if (this.layerNumber == 1 && this.instrumentMode == 3 && this.shp1[this.selectedShape - 1] != this.polygon_array.length) {\n            //this.polygon_array_ALL[this.selectedShape-1][kindOfShape]=this.polygon_array_ALL[this.selectedShape-1][kindOfShape++];\n            this.shp1[this.selectedShape - 1] = this.shp1[this.selectedShape - 1] + 1\n\n        }\n        if (this.layerNumber == 1 && this.instrumentMode == 3 && this.shp1[this.selectedShape - 1] == this.polygon_array.length) {\n            this.shp1[this.selectedShape - 1] = 0\n        }\n\n        if (this.layerNumber == 2 && this.instrumentMode == 3 && this.shp2[this.selectedShape2 - 1] != this.polygon_array2.length) {\n            //this.polygon_array_ALL[this.selectedShape-1][kindOfShape]=this.polygon_array_ALL[this.selectedShape-1][kindOfShape++];\n            this.shp2[this.selectedShape2 - 1] = this.shp2[this.selectedShape2 - 1] + 1\n\n        }\n        if (this.layerNumber == 2 && this.instrumentMode == 3 && this.shp2[this.selectedShape2 - 1] == this.polygon_array2.length) {\n            this.shp2[this.selectedShape2 - 1] = 0\n        }\n\n        //INC CUSTOM SHAPE MODE\n        if (this.layerNumber==1 && this.instrumentMode == 7) {\n            if (this.currentGrain == this.nGrain - 1) {\n                this.currentGrain = 0\n            } else {\n                this.currentGrain++\n            }\n        }\n        if (this.layerNumber==2 && this.instrumentMode == 7) {\n            if (this.currentGrain2 == this.nGrain - 1) {\n                this.currentGrain2 = 0\n            } else {\n                this.currentGrain2++\n            }\n        }\n\n        //INC CHANGE ROTATION MODE\n        if (this.layerNumber==1 && this.instrumentMode == 4 && this.selectedShape != 0) {\n            //rotate the selected shape\n            this.rot1[this.selectedShape - 1] = this.rot1[this.selectedShape - 1] + 1\n        }\n        if (this.layerNumber==2 && this.instrumentMode == 4 && this.selectedShape != 0) {\n            //rotate the selected shape\n            this.rot2[this.selectedShape2 - 1] = this.rot2[this.selectedShape2 - 1] + 1\n        }\n    }\n\n    public encoderDec() {\n        //LAYER SELECTION MODE\n        if (this.instrumentMode == 1 && this.layerNumber == 1) {\n            this.layerNumber = 2\n        } else if (this.instrumentMode == 1 && this.layerNumber == 2) {\n            this.layerNumber = 1\n\n        }\n\n        //TRACK SELECTION MODE\n        if (this.layerNumber==1 && this.instrumentMode == 2 && this.selectedShape != (0 || 1)) {\n            this.selectedShape--\n        } else if (this.instrumentMode == 2 && this.selectedShape == 1) {\n            this.selectedShape = this.maxNumShapes\n        }\n        if (this.layerNumber==2 && this.instrumentMode == 2 && this.selectedShape2 != (0 || 1)) {\n            this.selectedShape2--\n        } else if (this.instrumentMode == 2 && this.selectedShape2 == 1) {\n            this.selectedShape2 = this.maxNumShape2\n        }\n\n        //then CHANGE SHAPE MODE\n        if (this.layerNumber==1 && this.instrumentMode == 3 && this.shp1[this.selectedShape - 1] != 0) {\n            this.shp1[this.selectedShape - 1] = this.shp1[this.selectedShape - 1] - 1\n        } else if (this.instrumentMode == 3 && this.shp1[this.selectedShape - 1] == 0) {\n            this.shp1[this.selectedShape - 1] = this.polygon_array.length - 1\n        }\n        if (this.layerNumber==2 && this.instrumentMode == 3 && this.shp1[this.selectedShape - 1] != 0) {\n            this.shp2[this.selectedShape2 - 1] = this.shp2[this.selectedShape2 - 1] - 1\n        } else if (this.instrumentMode == 3 && this.shp2[this.selectedShape2 - 1] == 0) {\n            this.shp2[this.selectedShape2 - 1] = this.polygon_array2.length - 1\n        }\n\n\n        //CUSTOM SHAPE MODE\n        if (this.layerNumber==1 && this.instrumentMode == 7) {\n            if (this.currentGrain == 0) {\n                this.currentGrain = this.nGrain - 1\n            } else {\n                this.currentGrain--\n            }\n\n        }\n        if (this.layerNumber==2 && this.instrumentMode == 7) {\n            if (this.currentGrain2 == 0) {\n                this.currentGrain2 = this.nGrain - 1\n            } else {\n                this.currentGrain2--\n            }\n\n        }\n\n        //the CHANGE ROTATION MODE\n        if (this.layerNumber==1 && this.instrumentMode == 4 && this.selectedShape != 0) {\n            this.rot1[this.selectedShape - 1] = this.rot1[this.selectedShape - 1] - 1\n        }\n        if (this.layerNumber==2 && this.instrumentMode == 4 && this.selectedShape != 0) {\n            this.rot2[this.selectedShape2 - 1] = this.rot2[this.selectedShape2 - 1] - 1\n        }\n    }\n\n    public encoderButt() {\n        if (this.layerNumber==1 && this.instrumentMode == 7) {\n            if (this.polygon_array_c.includes(this.currentGrain)) {\n                for (let i = 0; i < this.polygon_array_c.length; i++) {\n                    if (this.polygon_array_c[i] === this.currentGrain) {\n                        this.polygon_array_c.splice(i, 1)\n                    }\n                }\n            } else {\n                this.polygon_array_c.push(this.currentGrain)\n            }\n            this.polygon_array_c.sort(function(a, b) {\n                return a - b\n            })\n\n        }\n        if (this.layerNumber==2 && this.instrumentMode == 7) {\n            if (this.polygon_array_c.includes(this.currentGrain2)) {\n                for (let i = 0; i < this.polygon_array_c.length; i++) {\n                    if (this.polygon_array_c[i] === this.currentGrain2) {\n                        this.polygon_array_c.splice(i, 1)\n                    }\n                }\n            } else {\n                this.polygon_array_c.push(this.currentGrain2)\n            }\n            this.polygon_array_c.sort(function(a, b) {\n                return a - b\n            })\n\n        }\n    }\n\n    public deleteShape() {\n        if (this.instrumentMode == 7) {\n            this.instrumentMode = 2\n        }\n        if (this.layerNumber==1){\n        this.shp1.splice(this.selectedShape - 1, 1)\n        this.rot1.splice(this.selectedShape - 1, 1)\n        this.maxNumShapes--\n        //start from skratch\n        if (this.maxNumShapes == 0) {\n            this.instrumentMode = 0\n        }\n        this.selectedShape = this.maxNumShapes\n    }\n    if (this.layerNumber==2){\n        this.shp2.splice(this.selectedShape2 - 1, 1)\n        this.rot1.splice(this.selectedShape2 - 1, 1)\n        this.maxNumShape2--\n        //start from skratch\n        if (this.maxNumShape2 == 0) {\n            this.instrumentMode = 0\n        }\n        this.selectedShape2 = this.maxNumShape2\n    }\n    }\n\n    //CREATE NEW LAYER FUNCTION\n    public createNewLayer() {\n        this.instrumentMode = 1\n\n        setTimeout(() => {\n        this.layerNumber++\n\n        }, 2000)\n    }\n\n    //TRACK SELECTION/ADD TRACK FUNCTION\n    public selectShape() {\n        this.instrumentMode = 2 // we are in track_mode!\n        if (this.layerNumber==1){\n        this.selectedShape = this.maxNumShapes\n        //if you press for 2 seconds you create a new track\n        if (this.instrumentMode != 0) {\n            this.myTimeout =  setTimeout(() => {\n                this.maxNumShapes = this.maxNumShapes + 1\n                this.updateArrays()\n            }, 2000)   \n        }\n        \n    }\n        if (this.layerNumber == 2){\n            this.selectedShape2 = this.maxNumShape2\n            if (this.instrumentMode != 0){\n                const myTimeout =  setTimeout(() => {\n                this.maxNumShape2 = this.maxNumShape2 + 1\n                this.updateArrays()\n              }, 2000)\n              \n            }\n          }\n        \n    }\n\n    ///CHANGE SHAPE AND GO INTO CUSTOM SHAPE FUNCTION\n    public changeShape() {\n        this.instrumentMode = 3 // we are in change_shape_mode!\n        setTimeout(() => {\n            if (this.layerNumber == 1){\n            this.instrumentMode = 7\n            this.maxNumShapes++\n            this.numCustShapes++\n            this.selectedShape = this.maxNumShapes\n\n            if (this.numCustShapes > 0) { //resets current grain to 0\n                this.currentGrain = 0\n            }\n            this.polygon_array_c = new Array()\n            //splice(this.maxNumShapes, 0, this.polygon_array_c);\n            this.polygon_array.push(this.polygon_array_c)\n            this.shp1.push(this.polygon_array.length - 1)\n            this.updateArrays()\n        }\n            if (this.layerNumber == 2){\n    \n                this.instrumentMode = 7\n                this.maxNumShape2++\n                this.numCustShapes++\n                this.selectedShape2=this.maxNumShape2\n                \n                if (this.numCustShapes>0){ //resets current grain to 0 \n                  this.currentGrain=0\n                }\n                this.polygon_array_c = new Array()\n                //splice(maxNumShapes, 0, polygon_array_c)\n                this.polygon_array2.push(this.polygon_array_c)\n                this.shp2.push(this.polygon_array2.length-1)\n                this.updateArrays()\n              \n            }\n          \n        }, 2000)\n        clearTimeout(this.myTimeout)\n       \n    \n    }\n\n    //ROTATE SHAPE FUNCTION\n    public rotateShape() {\n        this.instrumentMode = 4 // we are in rotation_mode!\n    }\n\n    public mouseReleased() {\n        clearTimeout(this.myTimeout)\n    }\n\n    //UPDATE ARRAYS\n    private updateArrays() {\n        // this is the rotation array, containing all the rotation indexes for just the FIRST layer. Its length is equal to the maximum number of shapes created in the related layer.\n        this.rot1.push(0)\n\n        if (this.layerNumber == 2) {\n            this.rot2.push(0)\n        }\n\n\n        //kind of shape index array relative to the first layer. here are stored the kind of shape of tracks. i set up this number to be 1,2,3...maxNumofShapes just to make the user distinguish between and avoid graphic overlap.\n\n        if (this.instrumentMode == 2) {\n            this.shp1.push(this.maxNumShapes - 1)\n        }\n\n        if (this.instrumentMode == 2 && this.layerNumber == 2) {\n            this.shp2.push(this.maxNumShape2 - 1)\n        }\n\n        this.selectedShape = this.maxNumShapes\n        this.selectedShape2 = this.maxNumShape2\n\n        /*if (instrumentMode == 7) {\n        this.shp1.push(polygon_array.length)\n        }*/\n    }\n}\n\n\nexport const MainSketch = new MainSketchClass()\n"]},"metadata":{},"sourceType":"module"}